'use strict';

const rulesRecommended = {
    'bot-whatsapp/func-prefix-goto-flow-return': 2,
    'bot-whatsapp/func-prefix-end-flow-return': 2,
    'bot-whatsapp/func-prefix-dynamic-flow-await': 2,
    'bot-whatsapp/func-prefix-state-update-await': 2,
    'bot-whatsapp/func-prefix-fall-back-return': 2,
    'bot-whatsapp/func-prefix-endflow-flowdynamic': 2,
};

function isInsideAddActionOrAddAnswer(node) {
    let currentNode = node;
    while (currentNode) {
        if (currentNode.type === 'CallExpression' &&
            currentNode.callee &&
            currentNode.callee.property &&
            (currentNode.callee.property.name === 'addAnswer' || currentNode.callee.property.name === 'addAction')) {
            return true;
        }
        currentNode = currentNode.parent;
    }
    return false;
}

const processDynamicFlowAwait = (context) => {
    return {
        'CallExpression[callee.name="flowDynamic"]'(node) {
            const parentNode = node.parent;
            // Verificar si estamos dentro de un 'addAction' o 'addAnswer'
            if (!isInsideAddActionOrAddAnswer(node)) {
                return;
            }
            // Verificar si el nodo padre es 'AwaitExpression', de lo contrario se reporta
            if (parentNode.type !== 'AwaitExpression') {
                context.report({
                    node,
                    message: 'Please use "await" before "flowDynamic" function',
                    fix: function (fixer) {
                        return fixer.insertTextBefore(node, 'await ');
                    },
                });
            }
        },
    };
};

const processEndFlowReturn = (context) => {
    return {
        'CallExpression[callee.name="endFlow"]'(node) {
            const parentNode = node.parent;
            // Verificar si estamos dentro de un 'addAction' o 'addAnswer'
            if (!isInsideAddActionOrAddAnswer(node)) {
                return;
            }
            // Verificar si nodo padre es de tipo ReturnStatement, si no lo es, reportar
            if (parentNode.type !== 'ReturnStatement') {
                context.report({
                    node,
                    message: 'Please ensure "endFlow" function is returned',
                    fix: function (fixer) {
                        return fixer.insertTextBefore(node, 'return ');
                    },
                });
            }
        },
    };
};

const processFallBackReturn = (context) => {
    return {
        'CallExpression[callee.name="fallBack"]'(node) {
            const parentNode = node.parent;
            // Verificar si estamos dentro de un 'addAction' o 'addAnswer'
            if (!isInsideAddActionOrAddAnswer(node)) {
                return;
            }
            // Verificar si nodo padre es de tipo ReturnStatement, si no lo es, reportar
            if (parentNode.type !== 'ReturnStatement') {
                context.report({
                    node,
                    message: 'Please ensure "fallBack" function is returned',
                    fix: function (fixer) {
                        return fixer.insertTextBefore(node, 'return ');
                    },
                });
            }
        },
    };
};

const processGotoFlowReturn = (context) => {
    return {
        'CallExpression[callee.name="gotoFlow"]'(node) {
            const parentNode = node.parent;
            // Verificar si estamos dentro de un 'addAction' o 'addAnswer'
            if (!isInsideAddActionOrAddAnswer(node)) {
                return;
            }
            // Verificar si nodo padre es de tipo ReturnStatement, si no lo es, reportar
            if (parentNode.type !== 'ReturnStatement') {
                context.report({
                    node,
                    message: 'Please ensure "gotoFlow" function is returned',
                    fix: function (fixer) {
                        return fixer.insertTextBefore(node, 'return ');
                    },
                });
            }
        },
    };
};

const processStateUpdateAwait = (context) => {
    return {
        'MemberExpression[property.name="update"]'(node) {
            // Verificar si el objeto es 'state'
            if (node.object.name !== 'state') {
                return;
            }
            if (node.object.name === 'state') {
                const sourceCode = context.getSourceCode();
                const rangeStart = node.range[0] - 6; // Longitud de "await "
                const rangeEnd = node.range[0];
                const parentNodeText = sourceCode.getText().substring(rangeStart, rangeEnd);
                if (parentNodeText.includes('await')) {
                    return;
                }
            }
            const parentNode = node.parent;
            // Verificar si estamos dentro de un 'addAction' o 'addAnswer'
            if (!isInsideAddActionOrAddAnswer(node)) {
                return;
            }
            // Verificar si el nodo padre es 'AwaitExpression', de lo contrario se reporta
            if (parentNode.type !== 'AwaitExpression') {
                context.report({
                    node,
                    message: 'Please use "await" before "state.update"',
                    fix: function (fixer) {
                        // Comprueba si existe un await antes de state.update
                        const sourceCode = context.getSourceCode();
                        const rangeStart = node.range[0] - 7; // Longitud de "await "
                        const rangeEnd = node.range[0];
                        const parentNodeText = sourceCode.getText().substring(rangeStart, rangeEnd);
                        if (parentNodeText.trim() !== 'await') {
                            return fixer.insertTextBefore(node, 'await ');
                        }
                    },
                });
            }
        },
    };
};

const processEndFlowWithFlowDynamic = (context) => {
    return {
        'CallExpression[callee.name="endFlow"]'(node) {
            if (!isInsideAddActionOrAddAnswer(node)) {
                return;
            }
            const blockStatement = context
                .getAncestors()
                .find((ancestor) => ancestor.type === 'BlockStatement');
            if (blockStatement) {
                const calleInsideCtx = blockStatement.body.map((j) => j?.expression?.argument?.callee?.name);
                if (calleInsideCtx.includes('flowDynamic')) {
                    context.report({
                        node,
                        message: 'Do not use endFlow in the same execution context as flowDynamic.',
                    });
                }
            }
        },
    };
};

const configs = {
    recommended: {
        rules: rulesRecommended,
    },
};
const rules = {
    'func-prefix-goto-flow-return': {
        meta: {
            fixable: 'code',
        },
        create: processGotoFlowReturn,
    },
    'func-prefix-fall-back-return': {
        meta: {
            fixable: 'code',
        },
        create: processFallBackReturn,
    },
    'func-prefix-end-flow-return': {
        meta: {
            fixable: 'code',
        },
        create: processEndFlowReturn,
    },
    'func-prefix-dynamic-flow-await': {
        meta: {
            fixable: 'code',
        },
        create: processDynamicFlowAwait,
    },
    'func-prefix-state-update-await': {
        meta: {
            fixable: 'code',
        },
        create: processStateUpdateAwait,
    },
    'func-prefix-endflow-flowdynamic': {
        meta: {
            fixable: 'code',
        },
        create: processEndFlowWithFlowDynamic,
    },
};

exports.configs = configs;
exports.rules = rules;
